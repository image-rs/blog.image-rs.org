---
layout: post
author: HeroicKatora
title: "The last and next year of image-rs"
co_authors: [Shnatsel]
---

The last year was mainly one of stability. Working up to `0.23` we had fixed
many outstanding stability risks and it continues to be one of the most
long-serving major versions in a while. In this post you find an overview on
the massive progress made with it, and outstanding issues that you could
contribute towards in 2021.

We also have a logo now:

<div style="background: center/contain no-repeat url('/assets/image-rs-logo.png'); width:100%; height:10em;"></div>

## The gif crate now 2x faster

The `gif` crate joins `png` in being on par with the relevant C implementation
in terms of performance!

These gains are thanks to a new LZW encoding/decoding library, [called
`weezl`][weezl]. It significantly improves on lzw crate in performance while
staying 100% safe, and also had an optional `no_std` mode. There is integration
with both `std` and `async` IO-interfaces, behind separate features. `weezl`,
written by the author of this post, is also maintained under the image-rs
organization that hosts a lot of format-specific image encoding/decoding
crates.

Since most of the time in decoding GIF files is spent in LZW decoding, the
gains from LZW have naturally translated to gif crate. TIFF files encoded with
LZW compression also benefit from this change. The latest versions of gif, tiff
and image all take advantage of this new library.

[weezl]: https://crates.io/crates/weezl

## Developments in 2020

Part of the stability work was the ability to upgrade decoder dependencies
behind the scenes. This allowed you to silently benefit from the improved `gif`
decoder as detailed above and other similar fixes across other decoders and it
will also enable similar updates for `png` soon.

This is directly reflected in dependencies and downloads. While previously
there was a long tail, the dependencies and downloads are now [dominantly for
recent versions](https://lib.rs/crates/image/rev) and thus quicker, more
secure, and more correct. (If you're still using `0.18` or `0.22`, you should
_really_ consider updating). We've also more than doubled our total downloads
over the last year!

All of this didn't stop progress. Take the `png` and `tiff` decoders that have
seen a significant increase in coverage of features. Add the fact that `png`
and `gif` are now quite competitive with their C counterparts. Also, the
`jpeg-decoder` crate that has fixed quite a lot of outstanding bugs in the
decoding process; The newly added bindings for `avif` decoders and encoders;
And not to forget improved and copyless image operations.

There are still many outstanding issues and unimplemented improvements. From
the point of view of a maintainer, some of the most pressing ones are listed in
the next sections, sorted roughly by topic.

## Fallbacks and Error logs

The decoders are strict, in many ways. There exist a few fallbacks here and
there, but not enough. The justification for this is that being too lenient in
accepted formats leads to an ossification of formats where particular
non-standard behavior by the most popular encoders is de-facto standardized
without appearing in any specification. For many older formats that ship has,
however, long sailed. We should thus accept the popular interpretation (e.g.
ImageMagick) of such extensions.

The issues goes a bit farther than this. It would be great to have a mode where
such details and nit-picks are remarked upon but decoding continues. Meanwhile
we do not want to dump them to `stderr`.

Related issues:
* <https://github.com/image-rs/image-png/issues/193>: Chunk buffer size is inconsistent with std recommendation
* <https://github.com/image-rs/image-png/issues/254>: Don't verify adler32 checksum by default 
* <https://github.com/image-rs/jpeg-decoder/issues/90>: Decoding Twice Error
* <https://github.com/image-rs/jpeg-decoder/issues/169>: Corrupted JPEG does not result in visible error code

## Supplementary information

The `image` library currently does not expose a consistent interface to
supplementary information such as color spaces, comments, copyright,
orientation, and other parts of EXIF. This starts at concrete treatment of
extension chunks in the decoder libraries and goes all the way to design work
for integrating those in the `ImageDecoder` trait and the `Reader`.

* <https://github.com/image-rs/image-gif/issues/40>: Allow reading loop control extension (so that it can be written again)
* <https://github.com/image-rs/image-gif/issues/79>: The treatment of extensions
* <https://github.com/image-rs/image-png/issues/116>: Support for encoding metadata chunks
* <https://github.com/image-rs/image-png/issues/221>: Treatment of unknown chunks
* <https://github.com/image-rs/image/issues/258>: Need more portable image coordinates.
* <https://github.com/image-rs/image/issues/1371>: Orientation field not found after load image and save

## Limits during decoding

Loading an image from a remote server, only to find out that it decompresses to
several gigabytes of memory and totally grinds your system to a halt/crashes
your program isn't great. We'd like to ensure that the decoders all have memory
and/or runtime limits that they check and abide to. This also helps with
fuzzing as it turns allows controlling for such use explicitly. Note that most
of the core libraries (png, gif, tiff) all have their own form of limits but
notably `jpeg-decoder` does not. Also, there is no common interface to control
them in `image` and to restrict decoding to such parsers that can enforce them.

* <https://github.com/image-rs/image/issues/938>: Library wide memory limits
* <https://github.com/image-rs/image/issues/1052>: Large CPU and memory consumption on decoding a crafted GIF file
* <https://github.com/image-rs/image/issues/1139>: Excessively slow parsing of certain files
* <https://github.com/image-rs/jpeg-decoder/issues/133>: Excessive memory allocation for small inputs
* <https://github.com/image-rs/jpeg-decoder/issues/134>: Slow parsing for small inputs

## Code style and Documentation

Code changes and gets old, sometimes quite a bit and very quickly. This can
manifest as the coding style of one part of the library being inconsistent with
the rest, leading to new contributors unwittingly basing their contributions on
outdated styles. This is a bit of problem for both parties: It makes reviews
harder and doesn't teach the right values to potentially new programmers.
Clippy isn't always helpful here as it neglects both API stability and our MSRV
commitment (1.34 at the moment, potentially changing this year).

This also concerns the documentation itself. Have you ever been puzzled by an
interface, only to find the correct use some hours later? Answers to these
question rarely end up as issues or, even rarer, as PRs. However, consider
there is no more understanding of your struggle than yourself. It's really easy
to slip into a mindset where you accept bad ergonomics as quirks and in many
cases a single additional sentence of documentation would help tremendously.

There is no dedicated issue tracking for most of these issues (for reasons
stated above) but there are a couple:

* <https://github.com/image-rs/image-png/issues/203>: Document BitDepth::Sixteen encoding 
* <https://github.com/image-rs/image/issues/598>: What is the meaning of conversion from RGB to luma?
* <https://github.com/image-rs/image/issues/788>: Mention the origin of the coordinate system in README/Documentation
* <https://github.com/image-rs/image/issues/1182>: Plan for improving the documentation structure

## Image Buffers

Lastly, raising a bit of awareness of an experimental image buffer library in
the hopes of gathering a few new eyes, use cases, and contributors. The
`ImageBuffer` is showing a few cracks in its design but replacing it directly
is also not quite feasible. It has chosen _one_ layout and encodes this within
its own type. Both of these aspects have proven to be too inflexible.

Using `Vec<T>` for representing pixels is not very efficient if one wants to
support operations that change the sample type. This is due to the fact that it
relies on the standard libraries use of allocators and the memory allocated for
a vector is tied to the _exact_ layout of the sample type. There is a concept
library to work around this restriction by storing everything as a highly
aligned byte buffer, which makes it unnecessary to track the sample type as a
type parameter to the buffer type itself. It's a work in progress found here:

<https://github.com/image-rs/canvas>

The flexible layout makes it seem like a reasonable goal to create integration
with the various texture layouts found in graphics crates such as [`wgpu`],
[`ash`], [`gtk`], the Linux DRM module, and [`image`], and enable some
interoperability between them.

[`wgpu`]: https://crates.io/crates/wgpu
[`ash`]: https://crates.io/crates/ash
[`gtk`]: https://crates.io/crates/gtk
[`image`]: https://crates.io/crates/image
